{"version":3,"sources":["webpack:///./src/views/test/upload/upload.vue?2df1","webpack:///./src/views/test/upload/upload-test1.vue?c762","webpack:///src/views/test/upload/upload-test1.vue","webpack:///./src/views/test/upload/upload-test1.vue?dc0a","webpack:///./src/views/test/upload/upload-test1.vue","webpack:///./src/views/test/upload/upload-test2.vue?3a2e","webpack:///src/views/test/upload/upload-test2.vue","webpack:///./src/views/test/upload/upload-test2.vue?47d3","webpack:///./src/views/test/upload/upload-test2.vue","webpack:///./src/views/test/upload/upload-test3.vue?bbcf","webpack:///src/views/test/upload/upload-test3.vue","webpack:///./src/views/test/upload/upload-test3.vue?ccd8","webpack:///./src/views/test/upload/upload-test3.vue","webpack:///src/views/test/upload/upload.vue","webpack:///./src/views/test/upload/upload.vue?f5e0","webpack:///./src/views/test/upload/upload.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","_v","model","value","callback","$$v","listType","expression","data","handleBeforeUpload","handleSuccess","handleError","fileList","slot","_s","staticRenderFns","url","uploadData","handleExceed","handleBeforeRemove","handleRemove","staticClass","component","handleRequest"],"mappings":"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","file":"js/chunk-2d2088c5.e7d4ad8d.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('p-page-header',{attrs:{\"title\":\"文件上传练习\"}}),_c('h4',[_vm._v(\"无鉴权时\")]),_c('upload-test1'),_c('h4',[_vm._v(\"有鉴权时\")]),_c('upload-test2'),_c('h4',[_vm._v(\"组件样式\")]),_c('upload-test3'),_c('h4',[_vm._v(\"二次封装自定义组件\")]),_c('el-select',{attrs:{\"placeholder\":\"请选择\",\"size\":\"small\"},model:{value:(_vm.listType),callback:function ($$v) {_vm.listType=$$v},expression:\"listType\"}},[_c('el-option',{attrs:{\"label\":\"text\",\"value\":\"text\"}}),_c('el-option',{attrs:{\"label\":\"picture\",\"value\":\"picture\"}}),_c('el-option',{attrs:{\"label\":\"picture-card\",\"value\":\"picture-card\"}})],1),_c('p-upload',{attrs:{\"action\":\"/file/upload\",\"data\":_vm.data,\"limit\":3,\"before-upload\":_vm.handleBeforeUpload,\"on-success\":_vm.handleSuccess,\"on-error\":_vm.handleError,\"list-type\":_vm.listType},model:{value:(_vm.fileList),callback:function ($$v) {_vm.fileList=$$v},expression:\"fileList\"}},[_c('template',{slot:\"tip\"},[_vm._v(\"123123\")])],2),_vm._v(_vm._s(_vm.fileList)+\" \")],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-upload',{attrs:{\"action\":_vm.url,\"file-list\":_vm.fileList,\"limit\":2,\"data\":_vm.uploadData,\"on-exceed\":_vm.handleExceed,\"before-upload\":_vm.handleBeforeUpload,\"on-success\":_vm.handleSuccess,\"before-remove\":_vm.handleBeforeRemove,\"on-remove\":_vm.handleRemove}},[_c('el-button',{attrs:{\"size\":\"small\",\"type\":\"primary\"}},[_vm._v(\"点击上传\")]),_c('div',{staticClass:\"el-upload__tip\",attrs:{\"slot\":\"tip\"},slot:\"tip\"},[_vm._v(\"只能上传jpg,png,jpeg,gif格式的图片\")])],1),_vm._v(\" fileList的值:\"+_vm._s(_vm.fileList)+\" \")],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div>\n\t\t<!-- \n\t\t\taction代表要上传文件的接口路径\n\t\t\t\n\t\t\tfile-list代表当前已经上传的文件列表fileList的结构为[{name:'文件名',url:'文件访问路径'},...]\n\t\t\t该值决定当前展示的文件列表的内容由于fileList并不是v-model进行双向绑定的数据所以我们需要在upload组件的\n\t\t\t不同的回调函数中通过参数对当前的fileList进行重新附值来实现已上传文件列表的更新\n\t\t\t\n\t\t\tlimit表示当前组件最多可以上传的文件数量\n\t\t\t\n\t\t\tdata表示上传文件时发送的请求中携带的其他参数，格式为json，参考实际的值\n\t\t\t\n\t\t\t以下需要注意on-的属性均为props中的参数通过v-bind绑定，并不是通过v-on绑定的函数，\n\t\t\t但是:on-exceed=\"handleExceed\"仍然可以定义到methods中，因为参数的类型为Function\n\t\t\t\n\t\t\ton-exceed是当上传文件的数量超过limit设置的值时触发的回调，可以在其中做提示\n\t\t\t\n\t\t\ton-success是文件上传请求执行成功时执行的回调函数，他以http协议的状态码为200时视为成功，而我们项目\n\t\t\t的后台接口的成功失败是在返回数据的data中设置的，并没有修改http协议的状态码，所以请求我们项目的接口无论\n\t\t\t成功还是失败都会触发on-success函数\n\t\t\t\n\t\t\tbefore-upload是文件执行上传操作之前的一个回调，可以在这里处理对文件类型的限制\n\t\t\t\n\t\t\tbefore-remove是当点击文件列表中删除某个文件的按钮时在执行删除操作之前触发，由于自带的删除功能仅仅是删除\n\t\t\t网页内的fileList中的数据，所以我们经常通过before-remove在删除本地数据之前先请求服务器接口删除服务器上的\n\t\t\t数据，然后在执行本地的文件列表数据删除\n\t\t\t\n\t\t\ton-remove在before-remove正常执行完之后会触发on-remove事件，我们通常在这里将处理完的fileList更新\n\t\t\t\n\t\t\t接下来我们看一下下面的逻辑处理\n\t\t -->\n\t\t<el-upload\n\t\t\t:action=\"url\"\n\t\t\t:file-list=\"fileList\"\n\t\t\t:limit=\"2\"\n\t\t\t:data=\"uploadData\"\n\t\t\t:on-exceed=\"handleExceed\"\n\t\t\t:before-upload=\"handleBeforeUpload\"\n\t\t\t:on-success=\"handleSuccess\"\n\t\t\t:before-remove=\"handleBeforeRemove\"\n\t\t\t:on-remove=\"handleRemove\"\n\t\t>\n\t\t\t<el-button size=\"small\" type=\"primary\">点击上传</el-button>\n\t\t\t<!-- upload提供的自定义插槽 -->\n\t\t\t<div slot=\"tip\" class=\"el-upload__tip\">只能上传jpg,png,jpeg,gif格式的图片</div>\n\t\t</el-upload>\n\t\tfileList的值:{{fileList}}\n\t</div>\n</template>\n\n<script>\n\texport default{\n\t\tname:'upload-test1',\n\t\tdata(){\n\t\t\treturn {\n\t\t\t\tfileList:[],//已上传文件列表的数组\n\t\t\t\t//文件上传的接口名，这里为什么会加上/shop-service/v1是因为\n\t\t\t\t//我们使用el-upload组件是通过内部的http对象发送的请求，并没有使用我们项目中的axios所以\n\t\t\t\t//我们在axios中设置的baseUrl在这里是不管用的\n\t\t\t\turl:'/shop-service/v1/file/upload/test',\n\t\t\t\t// 组件默认上传文件是会将文件以file:文件的值的形式传输，与后台接口的file对象能对应\n\t\t\t\t// 我们的后台接口除了file还有一个folder参数，所以可以通过这个对象传输\n\t\t\t\tuploadData:{\n\t\t\t\t\tfolder:'test'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmethods:{\n\t\t\t// 在选择完文件之后，执行上传文件之前触发\n\t\t  handleBeforeUpload(file){\n\t\t\t\t// 判断当前的文件类型如果不是这些类型的文件就弹出错误提示并中断上传操作\n\t\t\t\tif(!(file.name.indexOf('png') != -1\n\t\t\t\t\t||file.name.indexOf('jpg') != -1\n\t\t\t\t\t||file.name.indexOf('jpeg') != -1\n\t\t\t\t\t||file.name.indexOf('gif') != -1)){\n\t\t\t\t\tthis.$notify({\n\t\t\t\t\t\ttitle:'提示',\n\t\t\t\t\t\tmessage:'只能上传图片格式的文件',\n\t\t\t\t\t\ttype:'error'\n\t\t\t\t\t})\n\t\t\t\t\t// 通过return Promise.reject()可以实现中断上传操作，不在触发上传的函数\n\t\t\t\t\t// 但是这里要注意的是，组件内部会自动处理已经传入的fileList，在选择文件的时候就会对fileList增加一个\n\t\t\t\t\t// 本地数据，当我们中断上传时，组件内部会自动自行删除fileList，这样就会触发下面的beforeRemove和remove\n\t\t\t\t\treturn Promise.reject()\n\t\t\t\t}\n\t\t\t},\n\t\t\t// 在文件上传的接口http协议状态码为200时触发\n\t\t\t//res为上传接口返回的数据，file为upload封装的文件对象，包含上传返回的数据和上传前读取的本地文件对象\n\t\t\t//fileList是上传成功时组件内自动处理完的文件列表，这里我们需要手动将他赋值给this.fileList来实现组件\n\t\t\t//内外的数据同步（由于不是双向绑定所以需要人工处理）\n\t\t\thandleSuccess(res,file,fileList){\n\t\t\t\t// 由于每次上传的新文件一定是fileList的最后一个，所以在这里\n\t\t\t\t//直接将文件列表最后一个的name和url改成我们的后台接口返回的文件名和文件url\n\t\t\t\t//这么操作是因为如果不手动处理upload组件默认只会将选择文件时从本地读取的文件名name，并且不存在url属性\n\t\t\t\t//fileList上这样数据展示就有差异了，可以将下面两行注释掉体验一下\n\t\t\t\tfileList[fileList.length-1].name = res.data.fileName;\n\t\t\t\tfileList[fileList.length-1].url = res.data.url;\n\t\t\t\tthis.fileList = fileList\n\t\t\t},\n\t\t\t// 在上传的文件数量超过limit时触发\n\t\t\thandleExceed(){\n\t\t\t\tthis.$notify({\n\t\t\t\t\ttitle:'提示',\n\t\t\t\t\tmessage:'文件最多只能上传两个',\n\t\t\t\t\ttype:'error'\n\t\t\t\t})\n\t\t\t},\n\t\t\t// 在执行删除之前执行\n\t\t\t/**\n\t\t\t * 这里着重说明，如果beforeRemove和remove我们不做处理，组件内部会自动的在页面去掉我们删除的那一项数据\n\t\t\t * 但是这个做法不会改变我们传入的this.fileList的值，会造成数据不同步问题，还有一个问题就是，如果我们不\n\t\t\t * 处理的话，本地删除的文件其实在服务器上还在，这样我们就无形中创造了多余的垃圾文件。\n\t\t\t * 所以我们要在删除之前先调用服务器的删除文件接口，这里由于业务复杂，所以我们调用接口采用直接卸载vue文件内\n\t\t\t * 的方式不与vuex关联\n\t\t\t * \n\t\t\t */\n\t\t\tasync handleBeforeRemove(file,fileList){\n\t\t\t\t//这里判断是由于如果我们在上传文件时选择了错误的文件类型，upload组件也会走一遍删除逻辑\n\t\t\t\t//根据逻辑分析，我们上传成功的file中会保存我们创建的url属性\n\t\t\t\t//所以当file中含有url的时候表示是有人在删除已经上传成功的文件\n\t\t\t\tif(file.url){\n\t\t\t\t\t// 这里我们先询问用户是否确定要删除\n\t\t\t\t\tlet confirm = await this.$confirm('正在删除该文件，点击确认继续','提示',{type:'warning'}).catch(err => err)\n\t\t\t\t\tif(confirm == 'confirm'){\n\t\t\t\t\t\t// 确定之后我们调用服务器上的删除接口\n\t\t\t\t\t\tlet res =await this.$http({\n\t\t\t\t\t\t\turl:'/file/delete',\n\t\t\t\t\t\t\tparams:{\n\t\t\t\t\t\t\t\tpath:file.url\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod:'get'\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// 当用户确定删除且服务器上删除成功时我们才让删除逻辑向下走\n\t\t\t\t\t\tif(res.data.code == 200){\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//不满足条件时我们不允许删除逻辑向下走也就是remove事件不会执行\n\t\t\t\t\t\t\treturn Promise.reject()\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn Promise.reject()\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log('在取消上传时实际上我也执行了一次beforeRemove')\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\t// 在beforeRemove不被中断后执行\n\t\t\thandleRemove(file,fileList){\n\t\t\t\tconsole.log('在取消上传时实际上我也执行了一次remove')\n\t\t\t\tthis.fileList = fileList\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload-test1.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload-test1.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./upload-test1.vue?vue&type=template&id=322ed87d&\"\nimport script from \"./upload-test1.vue?vue&type=script&lang=js&\"\nexport * from \"./upload-test1.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-upload',{attrs:{\"action\":_vm.url,\"file-list\":_vm.fileList,\"limit\":2,\"data\":_vm.uploadData,\"on-exceed\":_vm.handleExceed,\"before-upload\":_vm.handleBeforeUpload,\"on-success\":_vm.handleSuccess,\"before-remove\":_vm.handleBeforeRemove,\"on-remove\":_vm.handleRemove,\"on-error\":_vm.handleError}},[_c('el-button',{attrs:{\"size\":\"small\",\"type\":\"primary\"}},[_vm._v(\"点击上传\")]),_c('div',{staticClass:\"el-upload__tip\",attrs:{\"slot\":\"tip\"},slot:\"tip\"},[_vm._v(\"只能上传jpg,png,jpeg,gif格式的图片\")])],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div>\n\t\t<!-- \n\t\t\t第一步：参数的说明我们在这里就不写了，在这里我们已经将action的值改成了后台有鉴权的接口地址\n\t\t\t我们先上传一个文件查看有什么不一样，操作完成之后发现文件上传之后展示的是本地选择的文件名\n\t\t\t而且控制台报错了，Cannot read property 'fileName' of undefined\n\t\t\t我们找到handleSuccess查看\n\t\t\t第二步：我们将 :http-request=\"handleRequest\"这个属性添加到组件中留的空白处,\n\t\t\t增加后我们在页面中再次上传一个文件，发现不报错了，并且控制台打印了一个信息，我们追踪一下发现\n\t\t\t是handleRequest执行了打印的信息中包含了action，data，onError，onSuccess等属性和方法\n\t\t\thttp-request是upload组件提供的一个重写上传逻辑的函数我们可以在这里获得组件的基本信息，并且\n\t\t\t在方法中自定义上传逻辑，也就是我们可以在这个组件中使用axios发送请求了。下面打开handleRequest\n\t\t\t中的注释部分的代码我们来阅读一下\n\t\t\t\n\t\t\t按流程阅读完后回到upload.vue\n\t\t -->\n\t\t<el-upload\n\t\t\t:action=\"url\"\n\t\t\t:file-list=\"fileList\"\n\t\t\t:limit=\"2\"\n\t\t\t:data=\"uploadData\"\n\t\t\t\n\t\t\t:on-exceed=\"handleExceed\"\n\t\t\t:before-upload=\"handleBeforeUpload\"\n\t\t\t:on-success=\"handleSuccess\"\n\t\t\t:before-remove=\"handleBeforeRemove\"\n\t\t\t:on-remove=\"handleRemove\"\n\t\t\t:on-error=\"handleError\"\n\t\t>\n\t\t\t<el-button size=\"small\" type=\"primary\">点击上传</el-button>\n\t\t\t<!-- upload提供的自定义插槽 -->\n\t\t\t<div slot=\"tip\" class=\"el-upload__tip\">只能上传jpg,png,jpeg,gif格式的图片</div>\n\t\t</el-upload>\n\t</div>\n</template>\n\n<script>\n\texport default{\n\t\tname:'upload-test1',\n\t\tdata(){\n\t\t\treturn {\n\t\t\t\tfileList:[],//已上传文件列表的数组\n\t\t\t\t//这里我们将url改成了有鉴权的接口地址\n\t\t\t\turl:'/shop-service/v1/file/upload',\n\t\t\t\t// 组件默认上传文件是会将文件以file:文件的值的形式传输，与后台接口的file对象能对应\n\t\t\t\t// 我们的后台接口除了file还有一个folder参数，所以可以通过这个对象传输\n\t\t\t\tuploadData:{\n\t\t\t\t\tfolder:'test'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmethods:{\n\t\t\t// 在请求错误时触发\n\t\t\thandleError(err){\n\t\t\t\tconsole.log(err)\n\t\t\t},\n\t\t\tasync handleRequest(upload){\n\t\t\t\tconsole.log(upload)\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t//当Content-Type为multipart/form-data时，我们的参数需要放在FormData对象中\n\t\t\t\t//对象通过append添加数据格式为key，value的形式与json类似\n\t\t\t\tlet f = new FormData();\n\t\t\t\tf.append('file',upload.file)\n\t\t\t\tf.append('folder',upload.data.folder)\n\t\t\t\t// 我们根据后台接口的参数，method，contentType来配置请求对象\n\t\t\t\tlet res =await this.$http({\n\t\t\t\t\turl:'/file/upload',\n\t\t\t\t\tmethod:'post',\n\t\t\t\t\tdata:f,\n\t\t\t\t\theaders:{\n\t\t\t\t\t\t'Content-Type':'multipart/form-data'\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t\n\t\t\t\tif(res.data.code == 200){\n\t\t\t\t\t// 当请求成功时我们通过Promise.resolve来结束当前方法，组件就会自动执行on-success函数\n\t\t\t\t\treturn Promise.resolve(res.data)\n\t\t\t\t}else{\n\t\t\t\t\t// 当请求失败是我们通过Promise.reject()就会执行on-error函数\n\t\t\t\t\t//比如我们将url改成错误路径\n\t\t\t\t\treturn Promise.reject(res.data)\n\t\t\t\t}*/\n\t\t\t\t\n\t\t\t},\n\t\t\t// 在选择完文件之后，执行上传文件之前触发\n\t\t  handleBeforeUpload(file){\n\t\t\t\t// 判断当前的文件类型如果不是这些类型的文件就弹出错误提示并中断上传操作\n\t\t\t\tif(!(file.name.indexOf('png') != -1\n\t\t\t\t\t||file.name.indexOf('jpg') != -1\n\t\t\t\t\t||file.name.indexOf('jpeg') != -1\n\t\t\t\t\t||file.name.indexOf('gif') != -1)){\n\t\t\t\t\tthis.$notify({\n\t\t\t\t\t\ttitle:'提示',\n\t\t\t\t\t\tmessage:'只能上传图片格式的文件',\n\t\t\t\t\t\ttype:'error'\n\t\t\t\t\t})\n\t\t\t\t\t// 通过return Promise.reject()可以实现中断上传操作，不在触发上传的函数\n\t\t\t\t\t// 但是这里要注意的是，组件内部会自动处理已经传入的fileList，在选择文件的时候就会对fileList增加一个\n\t\t\t\t\t// 本地数据，当我们中断上传时，组件内部会自动自行删除fileList，这样就会触发下面的beforeRemove和remove\n\t\t\t\t\treturn Promise.reject()\n\t\t\t\t}\n\t\t\t},\n\t\t\t// 在文件上传的接口http协议状态码为200时触发\n\t\t\t//res为上传接口返回的数据，file为upload封装的文件对象，包含上传返回的数据和上传前读取的本地文件对象\n\t\t\t//fileList是上传成功时组件内自动处理完的文件列表，这里我们需要手动将他赋值给this.fileList来实现组件\n\t\t\t//内外的数据同步（由于不是双向绑定所以需要人工处理）\n\t\t\thandleSuccess(res,file,fileList){\n\t\t\t\tconsole.log(res,file,fileList)\n\t\t\t\t//这里再次查看函数上的注释，然后我们打印res，会发现返回的是服务器上的错误信息\n\t\t\t\t//也就是说我们的上传接口调用并没有成功，这是因为我们这里调用的是有鉴权的接口\n\t\t\t\t//而el-upload组件并没有使用我们自己封装axios请求包，所以请求并没有携带token，\n\t\t\t\t//那么我们如何能让上传成功呢？回到代码最上方的注释查看第二步\n\t\t\t\tfileList[fileList.length-1].name = res.data.fileName;\n\t\t\t\tfileList[fileList.length-1].url = res.data.url;\n\t\t\t\tthis.fileList = fileList\n\t\t\t},\n\t\t\t// 在上传的文件数量超过limit时触发\n\t\t\thandleExceed(){\n\t\t\t\tthis.$notify({\n\t\t\t\t\ttitle:'提示',\n\t\t\t\t\tmessage:'文件最多只能上传两个',\n\t\t\t\t\ttype:'error'\n\t\t\t\t})\n\t\t\t},\n\t\t\t// 在执行删除之前执行\n\t\t\t/**\n\t\t\t * 这里着重说明，如果beforeRemove和remove我们不做处理，组件内部会自动的在页面去掉我们删除的那一项数据\n\t\t\t * 但是这个做法不会改变我们传入的this.fileList的值，会造成数据不同步问题，还有一个问题就是，如果我们不\n\t\t\t * 处理的话，本地删除的文件其实在服务器上还在，这样我们就无形中创造了多余的垃圾文件。\n\t\t\t * 所以我们要在删除之前先调用服务器的删除文件接口，这里由于业务复杂，所以我们调用接口采用直接卸载vue文件内\n\t\t\t * 的方式不与vuex关联\n\t\t\t * \n\t\t\t */\n\t\t\tasync handleBeforeRemove(file,fileList){\n\t\t\t\t//这里判断是由于如果我们在上传文件时选择了错误的文件类型，upload组件也会走一遍删除逻辑\n\t\t\t\t//根据逻辑分析，我们上传成功的file中会保存我们创建的url属性\n\t\t\t\t//所以当file中含有url的时候表示是有人在删除已经上传成功的文件\n\t\t\t\tif(file.url){\n\t\t\t\t\t// 这里我们先询问用户是否确定要删除\n\t\t\t\t\tlet confirm = await this.$confirm('正在删除该文件，点击确认继续','提示',{type:'warning'}).catch(err => err)\n\t\t\t\t\tif(confirm == 'confirm'){\n\t\t\t\t\t\t// 确定之后我们调用服务器上的删除接口\n\t\t\t\t\t\tlet res =await this.$http({\n\t\t\t\t\t\t\turl:'/file/delete',\n\t\t\t\t\t\t\tparams:{\n\t\t\t\t\t\t\t\tpath:file.url\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod:'get'\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// 当用户确定删除且服务器上删除成功时我们才让删除逻辑向下走\n\t\t\t\t\t\tif(res.data.code == 200){\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//不满足条件时我们不允许删除逻辑向下走也就是remove事件不会执行\n\t\t\t\t\t\t\treturn Promise.reject()\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn Promise.reject()\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log('在取消上传时实际上我也执行了一次beforeRemove')\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\t// 在beforeRemove不被中断后执行\n\t\t\thandleRemove(file,fileList){\n\t\t\t\tconsole.log('在取消上传时实际上我也执行了一次remove')\n\t\t\t\tthis.fileList = fileList\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload-test2.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload-test2.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./upload-test2.vue?vue&type=template&id=7d6671c0&\"\nimport script from \"./upload-test2.vue?vue&type=script&lang=js&\"\nexport * from \"./upload-test2.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-select',{attrs:{\"placeholder\":\"请选择\",\"size\":\"small\"},model:{value:(_vm.listType),callback:function ($$v) {_vm.listType=$$v},expression:\"listType\"}},[_c('el-option',{attrs:{\"label\":\"text\",\"value\":\"text\"}}),_c('el-option',{attrs:{\"label\":\"picture\",\"value\":\"picture\"}}),_c('el-option',{attrs:{\"label\":\"picture-card\",\"value\":\"picture-card\"}})],1),_c('el-upload',{attrs:{\"action\":_vm.url,\"file-list\":_vm.fileList,\"limit\":2,\"data\":_vm.uploadData,\"http-request\":_vm.handleRequest,\"on-exceed\":_vm.handleExceed,\"before-upload\":_vm.handleBeforeUpload,\"on-success\":_vm.handleSuccess,\"before-remove\":_vm.handleBeforeRemove,\"on-remove\":_vm.handleRemove,\"on-error\":_vm.handleError,\"list-type\":_vm.listType}},[(_vm.listType!='picture-card')?_c('el-button',{attrs:{\"size\":\"small\",\"type\":\"primary\"}},[_vm._v(\"点击上传\")]):_c('el-button',{attrs:{\"type\":\"text\"}},[_vm._v(\"+\")]),_c('div',{staticClass:\"el-upload__tip\",attrs:{\"slot\":\"tip\"},slot:\"tip\"},[_vm._v(\"只能上传jpg,png,jpeg,gif格式的图片\")])],1),_vm._v(\" fileList的值:\"+_vm._s(_vm.fileList)+\" \")],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div>\n\t\t<!-- \n\t\t\t组件中还有一个属性就是list-type属性我们可以通过他来决定组件的样式他有三个值 text，picture，picture-cards\n\t\t\t这里我们体验一下upload组件的样式切换\n\t\t\t体验完毕即可跳到下一个例子\n\t\t -->\n\t\t <el-select placeholder=\"请选择\" size=\"small\" v-model=\"listType\">\n\t\t\t <el-option label=\"text\" value=\"text\"></el-option>\n\t\t\t <el-option label=\"picture\" value=\"picture\"></el-option>\n\t\t\t <el-option label=\"picture-card\" value=\"picture-card\"></el-option>\n\t\t </el-select>\n\t\t<el-upload\n\t\t\t:action=\"url\"\n\t\t\t:file-list=\"fileList\"\n\t\t\t:limit=\"2\"\n\t\t\t:data=\"uploadData\"\n\t\t\t:http-request=\"handleRequest\"\n\t\t\t:on-exceed=\"handleExceed\"\n\t\t\t:before-upload=\"handleBeforeUpload\"\n\t\t\t:on-success=\"handleSuccess\"\n\t\t\t:before-remove=\"handleBeforeRemove\"\n\t\t\t:on-remove=\"handleRemove\"\n\t\t\t:on-error=\"handleError\"\n\t\t\t:list-type=\"listType\"\n\t\t>\n\t\t\t\n\t\t\t<el-button v-if=\"listType!='picture-card'\" size=\"small\" type=\"primary\">点击上传</el-button>\n\t\t\t<el-button v-else type=\"text\">+</el-button>\n\t\t\t<!-- upload提供的自定义插槽 -->\n\t\t\t<div slot=\"tip\" class=\"el-upload__tip\">只能上传jpg,png,jpeg,gif格式的图片</div>\n\t\t</el-upload>\n\t\tfileList的值:{{fileList}}\n\t</div>\n</template>\n\n<script>\n\texport default{\n\t\tname:'upload-test1',\n\t\tdata(){\n\t\t\treturn {\n\t\t\t\tfileList:[],//已上传文件列表的数组\n\t\t\t\t//这里我们将url改成了有鉴权的接口地址\n\t\t\t\turl:'/shop-service/v1/file/upload',\n\t\t\t\t// 组件默认上传文件是会将文件以file:文件的值的形式传输，与后台接口的file对象能对应\n\t\t\t\t// 我们的后台接口除了file还有一个folder参数，所以可以通过这个对象传输\n\t\t\t\tuploadData:{\n\t\t\t\t\tfolder:'test'\n\t\t\t\t},\n\t\t\t\tlistType:'text'\n\t\t\t}\n\t\t},\n\t\tmethods:{\n\t\t\t// 在请求错误时触发\n\t\t\thandleError(err){\n\t\t\t\tconsole.log(err)\n\t\t\t},\n\t\t\tasync handleRequest(upload){\n\t\t\t\t//当Content-Type为multipart/form-data时，我们的参数需要放在FormData对象中\n\t\t\t\t//对象通过append添加数据格式为key，value的形式与json类似\n\t\t\t\tlet f = new FormData();\n\t\t\t\tf.append('file',upload.file)\n\t\t\t\tf.append('folder',upload.data.folder)\n\t\t\t\t// 我们根据后台接口的参数，method，contentType来配置请求对象\n\t\t\t\tlet res =await this.$http({\n\t\t\t\t\turl:'/file/upload',\n\t\t\t\t\tmethod:'post',\n\t\t\t\t\tdata:f,\n\t\t\t\t\theaders:{\n\t\t\t\t\t\t'Content-Type':'multipart/form-data'\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tif(res.data.code == 200){\n\t\t\t\t\t// 当请求成功时我们通过Promise.resolve来结束当前方法，组件就会自动执行on-success函数\n\t\t\t\t\treturn Promise.resolve(res.data)\n\t\t\t\t}else{\n\t\t\t\t\t// 当请求失败是我们通过Promise.reject()就会执行on-error函数\n\t\t\t\t\t//比如我们将url改成错误路径\n\t\t\t\t\treturn Promise.reject(res.data)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t},\n\t\t\t// 在选择完文件之后，执行上传文件之前触发\n\t\t  handleBeforeUpload(file){\n\t\t\t\t// 判断当前的文件类型如果不是这些类型的文件就弹出错误提示并中断上传操作\n\t\t\t\tif(!(file.name.indexOf('png') != -1\n\t\t\t\t\t||file.name.indexOf('jpg') != -1\n\t\t\t\t\t||file.name.indexOf('jpeg') != -1\n\t\t\t\t\t||file.name.indexOf('gif') != -1)){\n\t\t\t\t\tthis.$notify({\n\t\t\t\t\t\ttitle:'提示',\n\t\t\t\t\t\tmessage:'只能上传图片格式的文件',\n\t\t\t\t\t\ttype:'error'\n\t\t\t\t\t})\n\t\t\t\t\t// 通过return Promise.reject()可以实现中断上传操作，不在触发上传的函数\n\t\t\t\t\t// 但是这里要注意的是，组件内部会自动处理已经传入的fileList，在选择文件的时候就会对fileList增加一个\n\t\t\t\t\t// 本地数据，当我们中断上传时，组件内部会自动自行删除fileList，这样就会触发下面的beforeRemove和remove\n\t\t\t\t\treturn Promise.reject()\n\t\t\t\t}\n\t\t\t},\n\t\t\t// 在文件上传的接口http协议状态码为200时触发\n\t\t\t//res为上传接口返回的数据，file为upload封装的文件对象，包含上传返回的数据和上传前读取的本地文件对象\n\t\t\t//fileList是上传成功时组件内自动处理完的文件列表，这里我们需要手动将他赋值给this.fileList来实现组件\n\t\t\t//内外的数据同步（由于不是双向绑定所以需要人工处理）\n\t\t\thandleSuccess(res,file,fileList){\n\t\t\t\tconsole.log(res,file,fileList)\n\t\t\t\t//这里再次查看函数上的注释，然后我们打印res，会发现返回的是服务器上的错误信息\n\t\t\t\t//也就是说我们的上传接口调用并没有成功，这是因为我们这里调用的是有鉴权的接口\n\t\t\t\t//而el-upload组件并没有使用我们自己封装axios请求包，所以请求并没有携带token，\n\t\t\t\t//那么我们如何能让上传成功呢？回到代码最上方的注释查看第二步\n\t\t\t\tfileList[fileList.length-1].name = res.data.fileName;\n\t\t\t\tfileList[fileList.length-1].url = res.data.url;\n\t\t\t\tthis.fileList = fileList\n\t\t\t},\n\t\t\t// 在上传的文件数量超过limit时触发\n\t\t\thandleExceed(){\n\t\t\t\tthis.$notify({\n\t\t\t\t\ttitle:'提示',\n\t\t\t\t\tmessage:'文件最多只能上传两个',\n\t\t\t\t\ttype:'error'\n\t\t\t\t})\n\t\t\t},\n\t\t\t// 在执行删除之前执行\n\t\t\t/**\n\t\t\t * 这里着重说明，如果beforeRemove和remove我们不做处理，组件内部会自动的在页面去掉我们删除的那一项数据\n\t\t\t * 但是这个做法不会改变我们传入的this.fileList的值，会造成数据不同步问题，还有一个问题就是，如果我们不\n\t\t\t * 处理的话，本地删除的文件其实在服务器上还在，这样我们就无形中创造了多余的垃圾文件。\n\t\t\t * 所以我们要在删除之前先调用服务器的删除文件接口，这里由于业务复杂，所以我们调用接口采用直接卸载vue文件内\n\t\t\t * 的方式不与vuex关联\n\t\t\t * \n\t\t\t */\n\t\t\tasync handleBeforeRemove(file,fileList){\n\t\t\t\t//这里判断是由于如果我们在上传文件时选择了错误的文件类型，upload组件也会走一遍删除逻辑\n\t\t\t\t//根据逻辑分析，我们上传成功的file中会保存我们创建的url属性\n\t\t\t\t//所以当file中含有url的时候表示是有人在删除已经上传成功的文件\n\t\t\t\tif(file.url){\n\t\t\t\t\t// 这里我们先询问用户是否确定要删除\n\t\t\t\t\tlet confirm = await this.$confirm('正在删除该文件，点击确认继续','提示',{type:'warning'}).catch(err => err)\n\t\t\t\t\tif(confirm == 'confirm'){\n\t\t\t\t\t\t// 确定之后我们调用服务器上的删除接口\n\t\t\t\t\t\tlet res =await this.$http({\n\t\t\t\t\t\t\turl:'/file/delete',\n\t\t\t\t\t\t\tparams:{\n\t\t\t\t\t\t\t\tpath:file.url\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod:'get'\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// 当用户确定删除且服务器上删除成功时我们才让删除逻辑向下走\n\t\t\t\t\t\tif(res.data.code == 200){\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//不满足条件时我们不允许删除逻辑向下走也就是remove事件不会执行\n\t\t\t\t\t\t\treturn Promise.reject()\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn Promise.reject()\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tconsole.log('在取消上传时实际上我也执行了一次beforeRemove')\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t},\n\t\t\t// 在beforeRemove不被中断后执行\n\t\t\thandleRemove(file,fileList){\n\t\t\t\tconsole.log('在取消上传时实际上我也执行了一次remove')\n\t\t\t\tthis.fileList = fileList\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload-test3.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload-test3.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./upload-test3.vue?vue&type=template&id=4a4b247f&\"\nimport script from \"./upload-test3.vue?vue&type=script&lang=js&\"\nexport * from \"./upload-test3.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","<template>\n\t<div>\n\t\t<p-page-header title=\"文件上传练习\"></p-page-header>\n\t\t<!-- \n\t\t 阅读顺序按照从上到下，将所有的代码和组件都阅读一遍\n\t\t -->\n\t\t<h4>无鉴权时</h4>\n\t\t<!-- 首先参考upload-test1.vue -->\n\t\t<upload-test1></upload-test1>\n\t\t<h4>有鉴权时</h4>\n\t\t<upload-test2></upload-test2>\n\t\t<h4>组件样式</h4>\n\t\t<upload-test3></upload-test3>\n\t\t<h4>二次封装自定义组件</h4>\n\t\t<!-- \n\t\t\t参考上述三个upload组件的案例我们发现自带的upload组件其实并不好用，他使用方式很复杂\n\t\t\t并且需要处理的生命周期也特别多，这个主要是因为开发组件的人为了组件的通用性更加良好\n\t\t\t所以提供了特别丰富的功能，这也让组件在使用场景变得及其难以维护，这种情况在公司中都会有\n\t\t\t前端架构师岗位的工程师将这种组件针对我们项目本身的需求进行二次封装，进而简化组件的复杂度\n\t\t -->\n\t\t<el-select placeholder=\"请选择\" size=\"small\" v-model=\"listType\">\n\t\t\t\t\t <el-option label=\"text\" value=\"text\"></el-option>\n\t\t\t\t\t <el-option label=\"picture\" value=\"picture\"></el-option>\n\t\t\t\t\t <el-option label=\"picture-card\" value=\"picture-card\"></el-option>\n\t\t</el-select>\n\t\t<!--\n\t\t\t我们来学习二次封装的组件p-upload\n\t\t\tv-model:这里我们将fileList改造成了双向绑定，无需处理他的变化\n\t\t\tdata:依然是追加的参数使用方式与原组件相同\n\t\t\taction:请求的路径，这里已经基于axios进行封装所以与普通接口传入的路径相同\n\t\t\tbefore-upload:这里与原组件参数和用法完全一致\n\t\t\ton-success:这里与原组件一样成功时的回调\n\t\t\ton-error:这里与原组件一样失败时的回调\n\t\t\tlist-type:这里与原组件一样依然是三个参数\n\t\t\t至此我们将复杂的upload组件简化成了只有7个属性，这样我们学习p-upload的使用即可\n\t\t\t学习完这里我们回到笔记中\n\t\t\t-->\n\t\t<p-upload \n\t\t\taction=\"/file/upload\" \n\t\t\tv-model=\"fileList\"\n\t\t\t:data=\"data\" \n\t\t\t:limit=\"3\"\n\t\t\t:before-upload=\"handleBeforeUpload\"\n\t\t\t:on-success=\"handleSuccess\"\n\t\t\t:on-error=\"handleError\"\n\t\t\t:list-type=\"listType\"\n\t\t\t>\n\t\t\t<!-- 组件默认是按钮化组件可通过default插槽进行替换 -->\n\t\t\t<!-- <el-button size=\"mini\" type=\"text\">上传</el-button> -->\n\t\t\t<!-- slot插槽，名称依然是tip -->\n\t\t\t<template slot=\"tip\">123123</template>\n\t\t</p-upload>{{fileList}}\n\t</div>\n</template>\n\n<script>\n\timport UploadTest1 from './upload-test1.vue'\n\timport UploadTest2 from './upload-test2.vue'\n\timport UploadTest3 from './upload-test3.vue'\n\texport default{\n\t\tcomponents:{\n\t\t\tUploadTest1,\n\t\t\tUploadTest2,\n\t\t\tUploadTest3\n\t\t},\n\t\tname:'upload',\n\t\tdata(){\n\t\t\treturn {\n\t\t\t\tdata:{\n\t\t\t\t\tfolder:'test',\n\t\t\t\t},\n\t\t\t\tfileList:[],\n\t\t\t\tlistType:'text'\n\t\t\t}\n\t\t},\n\t\tmethods:{\n\t\t\thandleBeforeUpload(file){\n\t\t\t\t// 判断当前的文件类型如果不是这些类型的文件就弹出错误提示并中断上传操作\n\t\t\t\tif(!(file.name.indexOf('png') != -1\n\t\t\t\t\t||file.name.indexOf('jpg') != -1\n\t\t\t\t\t||file.name.indexOf('jpeg') != -1\n\t\t\t\t\t||file.name.indexOf('gif') != -1)){\n\t\t\t\t\tthis.$notify({\n\t\t\t\t\t\ttitle:'提示',\n\t\t\t\t\t\tmessage:'只能上传图片格式的文件',\n\t\t\t\t\t\ttype:'error'\n\t\t\t\t\t})\n\t\t\t\t\t// 通过return Promise.reject()可以实现中断上传操作，不在触发上传的函数\n\t\t\t\t\t// 但是这里要注意的是，组件内部会自动处理已经传入的fileList，在选择文件的时候就会对fileList增加一个\n\t\t\t\t\t// 本地数据，当我们中断上传时，组件内部会自动自行删除fileList，这样就会触发下面的beforeRemove和remove\n\t\t\t\t\treturn Promise.reject()\n\t\t\t\t}\n\t\t\t},\n\t\t\thandleSuccess(res,file,fileList){\n\t\t\t\tconsole.log(res,file,fileList)\n\t\t\t},\n\t\t\thandleError(err){\n\t\t\t\tconsole.log(err)\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./upload.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./upload.vue?vue&type=template&id=36713cda&\"\nimport script from \"./upload.vue?vue&type=script&lang=js&\"\nexport * from \"./upload.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}